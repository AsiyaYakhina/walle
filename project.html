

  <!-- 
  Kelsey Reiman
  11/1/14 
  CS 307
  heartCurve.html

  Creates a cubic bezier curve that is the shape of half a heart

  I learned how to make bezier curves in three.js from: 
  http://www.lab4games.net/zz85/blog/2014/09/08/rendering-lines-and-bezier-curves-in-three-js-and-webgl/
-->
<html>
<head>
  <title>Heart Curve</title>
  <style>      
  canvas {
    display: block;
    margin: 10px auto;
    width: 80%;
    height: 750px;
  }
  </style>
  <script src="http://cs.wellesley.edu/~cs307/threejs/libs/three.min.js"></script>
  <script src="http://cs.wellesley.edu/~cs307/threejs/libs/OrbitControls.js"></script>
  <script src="http://cs.wellesley.edu/~cs307/threejs/libs/tw.js"></script>
  <script src="http://cs.wellesley.edu/~cs307/threejs/libs/dat.gui.min.js"></script>
  <script src="http://cs.wellesley.edu/~cs307/threejs/dirksen/libs/spin.js"></script>
  <script src="http://cs.wellesley.edu/~cs307/threejs/dirksen/libs/ThreeBSP.js"></script>
  <script src="marble.js"></script>
  <script src="eyeBase.js"></script>
  <script src="materials.js"></script>

</head>
<body>

  <script id="prog">

  var renderer = new THREE.WebGLRenderer();
  //renderer.shadowMapEnabled = true;
  renderer.shadowMapSoft = true;

  renderer.shadowCameraNear = 1;
  renderer.shadowCameraFar = 70;
  renderer.shadowCameraFov = 50;

  renderer.shadowMapBias = 0.0039;
  renderer.shadowMapDarkness = 0.5;
  renderer.shadowMapWidth = 10;
  renderer.shadowMapHeight = 10;


  var scene = new THREE.Scene(); 
  TW.mainInit(renderer,scene);
  var size = 2;
  var state = TW.cameraSetup(renderer,scene, {minx:-10,maxx:10,miny:-30,maxy:20,minz:0,maxz:0});

// DELETE LATER
var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } ); 
var material2 = new THREE.MeshBasicMaterial({color: 0xDC630A});



function createEyeFront(glassEye, glassCam) {
  var eyeFront = new THREE.Object3D();


  glassEye.scale.z = 0.7;


  var eyeBigCircGeom = new THREE.TorusGeometry( 1.9, 0.1, 16, 100 ); 
  var eyeBigCirc = new THREE.Mesh( eyeBigCircGeom,steelMaterial );
  eyeBigCirc.position.set(-2.5, 0.8,5 );

  var eyeBorderGeom = new THREE.TorusGeometry(1, 0.1, 16, 100);
  var eyeBorder = new THREE.Mesh(eyeBorderGeom, steelMaterial);
  eyeBorder.position.set(-2.5,1,5.1);


  var eyeLightPartGeom = new THREE.CircleGeometry(1,100);
  eyeLightPart = new THREE.Mesh(eyeLightPartGeom, eyeLightMaterial);
  eyeLightPart.position.set(-2.5,1,5.1);
  // scene.add(eyeLightPart);


  var eyeDarkPartGeom = new THREE.CircleGeometry(1.9,100);
  var eyeDarkPart = new THREE.Mesh(eyeDarkPartGeom, eyeDarkMaterial);
  eyeDarkPart.position.set(-2.5, 0.8,5);
  // scene.add(eyeDarkPart);

  var pupilGeom = new THREE.CircleGeometry(0.7, 100);
  var pupil = new THREE.Mesh(pupilGeom, eyeDarkMaterial);
  pupil.position.set(-2.5, 1,5.2);
  // scene.add(pupil);

  eyeFront.add(eyeBigCirc);
  eyeFront.add(glassEye);
  eyeFront.add(eyeBorder);
  eyeFront.add(eyeLightPart);
  eyeFront.add(eyeDarkPart);
  eyeFront.add(pupil);



  glassEye.position.set(-2.5, 0.8,5);
  glassCam.position.set(-2.5,0.8,5);

  return eyeFront;

}

var glassEyeL;
var glassEyeCamL; 
var glassEyeR;
var glassEyeCamR; 

var marbleSet1 = createMarble(0x524CFD, 0x444444, 5, 1.9);
glassEyeL = marbleSet1[0];
glassEyeCamL = marbleSet1[1];

var marbleSet2 = createMarble(0x524CFD, 0x444444, 5, 1.9);
glassEyeR = marbleSet2[0];
glassEyeCamR = marbleSet2[1];

function createHead() {
  var head = new THREE.Object3D();

  headGeom = new THREE.BoxGeometry(4,2.5,3);
  addTextureCoords(headGeom, 3, 3);
  var texturedHeadBox = new THREE.Mesh(headGeom, eyeCoverMaterial);
  texturedHeadBox.position.set(0.8,1.2,1);

  var eyeBaseR = createEyeBase(1);
  eyeBaseR.position.set(7,-1,-2);
  head.add(eyeBaseR);

  var eyeBaseL = createEyeBase(-1);
  eyeBaseL.position.set(-5,-1,3);
  head.add(eyeBaseL);

  var eyeFrontL = createEyeFront(glassEyeL, glassEyeCamL);
  eyeFrontL.position.set(1,1.4,-1.9)
  head.add(eyeFrontL);

  var eyeFrontR = createEyeFront(glassEyeR, glassEyeCamR);
  eyeFrontR.position.set(6,1.4,-1.9);
  head.add(eyeFrontR);
  head.add(texturedHeadBox);


  return head;
}

var head = createHead();
head.position.y = -1;
scene.add(head);



function createTexturedNeck(){

     var neck = new THREE.Shape();
    neck.moveTo(0,0);
    neck.lineTo(2,-1)
    neck.lineTo(2,-4);
    neck.lineTo(1,-6);
    neck.lineTo(0.5,-5);
    neck.lineTo(0.5, -3);
    neck.lineTo(0,-2);
    neck.moveTo(0,0);

        var options2 = {
      amount: 2,
      bevelThickness: 0,
      bevelSize: 0,
      bevelSegments: 3,
      bevelEnabled: false,
      curveSegments: 12,
      steps: 1
    };

  var yellowTexture = new THREE.ImageUtils.loadTexture("yellowMetal.jpg", 
    new THREE.UVMapping(),
    function () {
      console.log("yellowTexture is loaded.");
      imageLoaded = true;
      TW.render();
    });
  yellowTexture.wrapS = yellowTexture.wrapT = THREE.MirroredRepeatWrapping;
  yellowTexture.repeat.set( 1 / 7, 1 / 7 );
  yellowTexture.offset.set( 0.8, 0.9 );
  var yellowMaterial = new THREE.MeshPhongMaterial(
    { color: 0x898989,
      specular:0xFFFFFF,
      shininess: 0,
      map: yellowTexture,
      receiveShadow: true
    });

  var neckGeom = new THREE.ExtrudeGeometry(neck, options2);
   // neckGeom.applyMatrix(new THREE.Matrix4().makeTranslation(-20, 0, 0));
   var texturedNeck = new THREE.SceneUtils.createMultiMaterialObject(neckGeom, [yellowMaterial]);
   return texturedNeck;
 }

 var neckDetail = createTexturedNeck();
  // neckDetail.rotation.y = 2*Math.PI-Math.PI/2;
  // neckDetail.rotation.x =2*Math.PI- Math.PI/6;
  // neckDetail.position.set(2,8.5,18);
  scene.add(neckDetail);

  function createNeck() {

    var wholeNeck = new THREE.Object3D();    

  // var neckGeom = new THREE.ExtrudeGeometry(neck, options2);
  // // var neckDetail = new THREE.SceneUtils.createMultiMaterialObject(neckGeom, [yellowMaterial]);
  // var neckDetail = new THREE.Mesh(neckGeom, yellowMaterial);
  // neckDetail.rotation.y = 2*Math.PI-Math.PI/2;
  // neckDetail.rotation.x =2*Math.PI- Math.PI/6;
  // neckDetail.position.set(2,-1.5,0.5);
  // wholeNeck.add(neckDetail);

  var bodyCylGeom = new THREE.CylinderGeometry(1, 1, 2.5, 32 );
  var bodyCyl = new THREE.Mesh(bodyCylGeom, yellowMaterialForCyl );

  var bodyDiscGeom = new THREE.CylinderGeometry(1, 1, 0.4, 32 );
  var bodyDisc = new THREE.Mesh(bodyDiscGeom, yellowMaterialForCyl);

  var neckBaseGeom = new THREE.CylinderGeometry(1,1.6, 4, 32, true);
  var neckBase = new THREE.Mesh(neckBaseGeom, yellowNeckMat);


  var neckHolderGeom = new THREE.CylinderGeometry(1, 1, 0.4, 32);
  var neckHolder1 = new THREE.Mesh(neckHolderGeom, eyeCoverMaterial);

  var neckHolder2 = new THREE.Mesh(neckHolderGeom, eyeCoverMaterial);

  bodyCyl.rotation.z=Math.PI/2;
  bodyCyl.position.set(1,-5,3);
  bodyDisc.rotation.x = Math.PI/6;
  bodyDisc.position.set(1,-6,2.4);

  neckBase.position.set(1,-8,1.3);
  neckBase.rotation.x = Math.PI/6
  neckHolder1.scale.x = 1.5;
  neckHolder2.scale.x=1.5;
  neckHolder1.rotation.z = Math.PI/2;
  neckHolder2.rotation.z=Math.PI/2;
  neckHolder1.position.set(-0.6,-9.2,1);
  neckHolder2.position.set(2.5, -9.2,1);
  wholeNeck.add(bodyCyl);
  wholeNeck.add(bodyDisc);
  wholeNeck.add(neckBase);
  wholeNeck.add(neckHolder1);
  wholeNeck.add(neckHolder2);

  return wholeNeck;
}

wholeNeck = createNeck();
scene.add(wholeNeck);



function addTextureCoords(boxGeom, maxT, maxS) {

  var UVs = [];
  function faceCoords(as,at, bs,bt, cs,ct) {
    UVs.push( [ new THREE.Vector2(as,at),
      new THREE.Vector2(bs,bt),
      new THREE.Vector2(cs,ct)] );
  }
      // front
      faceCoords(0,0, maxS,0, maxS,maxT);
      faceCoords(0,0, maxS,maxT, 0,maxT);
      
      faceCoords(maxS,0, 0,maxT, 0,0);
      faceCoords(maxS,0, maxS,maxT, 0,maxT);
         // sides
         faceCoords(maxS,0, 0,maxT, 0,0);
         faceCoords(maxS,maxT, 0,maxT, maxS,0);
         faceCoords(maxS,0, maxS,maxT, 0,0);
         faceCoords(maxS,maxT, 0,maxT, 0,0);
      // floor
      faceCoords(0,0, maxS,0, 0,maxT);
      faceCoords(maxS,0, maxS,maxT, 0,maxT);
      // Finally, attach this to the geometry
      boxGeom.faceVertexUvs = [ UVs ];

    }

    var armStartGeom = new THREE.CylinderGeometry(0.8,0.8,2,32);
    var armStart = new THREE.Mesh(armStartGeom, material2);
    var armStart2 = new THREE.Mesh(armStartGeom, material2);

 

    var bodyCover = new THREE.Shape();
    bodyCover.moveTo(0,0);
    bodyCover.lineTo(13,0);
    bodyCover.lineTo(13,-2);
    bodyCover.lineTo(12.7,-2);
    bodyCover.lineTo(12.7, -0.4);
    bodyCover.lineTo(0,-0.4);

    var wheel1 = new THREE.Shape();
    wheel1.moveTo(0.3,0);
    wheel1.bezierCurveTo(9,-8,1,-8, 1,-8);
    wheel1.lineTo(-1,-8)
    wheel1.bezierCurveTo(-6,-7,0.3, 0,0.3,0);


    var arm = new THREE.Shape();
    arm.moveTo(1.4,-0.31);
    arm.lineTo(3,-2);
    arm.lineTo(3, -4);
    arm.lineTo(2.5, -4);
    arm.lineTo(2.5,-2);
    arm.lineTo(1,-1.9);



    var neckPoints = [];
    neckPoints.push(new THREE.Vector3(0,0.5,0));
    neckPoints.push(new THREE.Vector3(1, -0.8, 0));
    neckPoints.push(new THREE.Vector3(0.8, -1.75,0));
    neckPoints.push(new THREE.Vector3(0, -2,0));

    var neckPoints2 = [];
    neckPoints2.push(new THREE.Vector3(0,0.5,0));
    neckPoints2.push(new THREE.Vector3(-1, -0.8, 0));
    neckPoints2.push(new THREE.Vector3(-0.8, -1.75,0));
    neckPoints2.push(new THREE.Vector3(0, -2,0));

    var wireGeom1 = new THREE.TubeGeometry(new THREE.SplineCurve3(neckPoints), 100, 0.1, 100, false);
    var wireOne = createMeshTube(wireGeom1);


    var wireGeom2 = new THREE.TubeGeometry(new THREE.SplineCurve3(neckPoints2), 100, 0.1, 100, false);
    var wireTwo= createMeshTube(wireGeom2);




    var bodyBoxGeom = new THREE.BoxGeometry(12,10,12);
    var bodyBox = new THREE.Mesh(bodyBoxGeom, material);

    var sholderGeom = new THREE.CylinderGeometry(0.7,0.7,2,5,32);
    var sholder = new THREE.Mesh(sholderGeom, material2);
    var sholder2 = new THREE.Mesh(sholderGeom, material2);
    var handGeom = new THREE.BoxGeometry(1.4,1,10);
    var hand = new THREE.Mesh(handGeom, material2);
    var hand2 = new THREE.Mesh(handGeom, material2);
    var wristGeom = new THREE.CylinderGeometry(0.4,0.4,3, 32);
    var wrist = new THREE.Mesh(wristGeom, material);
    var wrist2 =  new THREE.Mesh(wristGeom, material);




    var options = {
      amount: 5,
      bevelThickness: 0,
      bevelSize: 0,
      bevelSegments: 3,
      bevelEnabled: false,
      curveSegments: 12,
      steps: 1
    };

    var options2 = {
      amount: 2,
      bevelThickness: 0,
      bevelSize: 0,
      bevelSegments: 3,
      bevelEnabled: false,
      curveSegments: 12,
      steps: 1
    };
    var options3 = {
      amount: 14,
      bevelThickness: 0,
      bevelSize: 0,
      bevelSegments: 0,
      bevelEnabled: false,
      curveSegments: 0,
      steps: 1
    };

    var options4 = {
      amount: 1.4,
      bevelThickness: 0,
      bevelSize: 0,
      bevelSegments: 0,
      bevelEnabled: false,
      curveSegments: 0,
      steps: 1
    };

    var textureYellowDetail = new THREE.ImageUtils.loadTexture("yellowDetail.jpg", 
      new THREE.UVMapping(),
      function () {
        console.log("yellowDetail is loaded.");
        imageLoaded = true;
        TW.render();
      });



    textureYellowDetail.wrapS = textureYellowDetail.wrapT = THREE.MirroredRepeatWrapping;
  // textureYellowDetail.repeat.set( 1 / 10, 1 / 10 );
  // textureYellowDetail.offset.set( 0.8, 0.9 );


  var yellowDetailMat = new THREE.MeshPhongMaterial(
    { color: 0x898989,
      specular:0xFFFFFF,
      shininess: 0,
      map: textureYellowDetail,
      castShadow: true
    });



  topBoxGeom = new THREE.BoxGeometry(1.4,2.2,0.3);
  addTextureCoords(headGeom, 3, 3);
  topBox = new THREE.Mesh (topBoxGeom, yellowDetailMat);




  var bodyTop = createMesh(new THREE.ExtrudeGeometry(bodyCover, options3));

  var wheelOne = createMesh(new THREE.ExtrudeGeometry(wheel1, options4));
  var wheelTwo = createMesh(new THREE.ExtrudeGeometry(wheel1, options4))

  var armFirst = createMesh(new THREE.ExtrudeGeometry(arm,options4));
  var armSecond = createMesh(new THREE.ExtrudeGeometry(arm,options4));

  var armFirst2 = createMesh(new THREE.ExtrudeGeometry(arm,options4));
  var armSecond2 = createMesh(new THREE.ExtrudeGeometry(arm,options4));


  function modifyTextureParams(geometry, numX, numY) {
    var f, faces = geometry.faces, len = faces.length;
    var UVs = geometry.faceVertexUvs[0];
      // var back = new THREE.Vector3(0,0,-1);
      for( f=0; f < len; f++ ) {
            // console.log("modifying face "+f);
            // modify the s, which is x here
            var face = UVs[f];
            face[0].x = face[0].x*numX
            face[1].x = face[1].x*numX
            face[2].x = face[2].x*numX
            face[0].y = face[0].y*numY
            face[1].y = face[1].y*numY
            face[2].y = face[2].y*numY
          }
          geometry.uvsNeedUpdate = true;
        }



        function createMeshTube(geom) {

              // assign two materials
              //var meshMaterial = new THREE.MeshNormalMaterial();
              var meshMaterial = new THREE.MeshBasicMaterial({color: 0x00ff00, transparent: true, opacity: 0.2});

              var wireFrameMat = new THREE.MeshBasicMaterial();
              wireFrameMat.wireframe = true;

              // create a multimaterial
              var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMat]);

              return mesh;
            }


            function createMesh(geom) {

              geom.applyMatrix(new THREE.Matrix4().makeTranslation(-20, 0, 0));

              // assign two materials
              var meshMaterial = new THREE.MeshNormalMaterial({transparent: true, opacity: 0.7});

              //  meshMaterial.side = THREE.DoubleSide;
              var wireFrameMat = new THREE.MeshBasicMaterial();
              wireFrameMat.wireframe = true;

              // create a multimaterial
              var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial]);

              return mesh;
            }




  //eyeSecond.rotation.z = Math.PI*2 - Math.PI/6;

  // neckDetail.rotation.y = 2*Math.PI-Math.PI/2;
  // neckDetail.rotation.x =2*Math.PI- Math.PI/6;
  // neckDetail.position.set(2,8.5,18);


  
  //glassBall.scale.z = 0.8;
  // sphereCamera.position.set(10, 50, 25);

  //glassBallCam.position
  //eyeBallOne.scale.z= 0.7;
  //eyeBallOne.position.set(-2.5, 0.8,5);
  //eyeBallTwo.scale.z= 0.7;
  //eyeBallTwo.position.set(4.1, 1.2,5);


  topBox.rotation.x = 2*Math.PI-Math.PI/6;
  topBox.position.set(1,-2.8,3.6);
  wireOne.position.set(1.5,-0.5,3.5);
  wireTwo.position.set(0.6,-0.5,3.5);

  bodyBox.position.set(1,-14,0);
  bodyTop.rotation.y = Math.PI/2;
  bodyTop.position.set(-6,-8.7,-13.2);

  wheelOne.rotation.y = Math.PI/2;
  wheelOne.scale.x = 1.3;
  wheelOne.position.set(6.9,-12.7,-25);
  wheelTwo.scale.x = 1.3;
  wheelTwo.rotation.y = Math.PI/2;
  wheelTwo.position.set(-8,-12.7,-25);
  sholder.position.set(0,0,0);
  sholder2.position.set(0,0,0);
  hand.position.set(0,0,5.8);
  hand.rotation.z = Math.PI/2;
  hand2.position.set(0,0,5.8);
  hand2.rotation.z = Math.PI/2;
  wrist.position.set(0,0,11);
  wrist.rotation.x= Math.PI/2;
  wrist2.position.set(0,0,11);
  wrist2.rotation.x= Math.PI/2;
  armFirst.rotation.y = Math.PI*2-Math.PI/2;
  armFirst.position.set(1.4,1.1,31);
  armFirst2.rotation.y = Math.PI*2-Math.PI/2;
  armFirst2.position.set(1.4,1.1,31);
  armSecond.rotation.y = Math.PI*2-Math.PI/2; 
  armSecond.position.set(-0.2,1.1,31)
  armSecond2.rotation.y = Math.PI*2-Math.PI/2; 
  armSecond2.position.set(-0.2,1.1,31)
  armStart.position.set(0,0,12.3);
  armStart.rotation.z = Math.PI/2;
  armStart2.position.set(0,0,12.3);
  armStart2.rotation.z = Math.PI/2;



  var wholeHand = new THREE.Object3D();
  wholeHand.add(sholder);
  wholeHand.add(hand);
  wholeHand.add(wrist);
  wholeHand.add(armFirst);
  wholeHand.add(armSecond);
  wholeHand.add(armStart);
  wholeHand.position.set(7.4,-11.5,0);
  wholeHand.rotation.x= Math.PI/18;

  var wholeHand2 = new THREE.Object3D();
  wholeHand2.add(sholder2);
  wholeHand2.add(hand2);
  wholeHand2.add(wrist2);
  wholeHand2.add(armFirst2);
  wholeHand2.add(armSecond2);
  wholeHand2.add(armStart2);
  wholeHand2.position.set(-5.5,-11.5,0);
  wholeHand2.rotation.x= Math.PI*2-Math.PI/18;


  // lights

  ambLight= new THREE.AmbientLight( 0xA8A8A8, 0.1);


  sptLight = new THREE.SpotLight( 0x999999, 
               2,               //params.spotLightIntensity,
              300, //params.spotLightDistance,
              2,//params.spotLightAngle,
              20             //params.spotLightExp
              ); 
                   // positioning the bottom spotlight
                   sptLight.position.set( 0,50,-10);
                   sptLight.shadowCameraNear = 0.1;
                   sptLight.castShadow = true;             

                   sptLight.shadowDarkness = 0.5;
                   sptLight.shadowCameraVisible = true;
                   sptLight.shadowCameraTop = 0.5;


                   dirLight = new THREE.DirectionalLight(0xC2C2C2, 0.4);
          //setting up the light at a direction which will fall on the back, left walls and the floor
          dirLight.position.set(0.5, 1, 1);
          dirLight.castShadow = true;             

          dirLight.shadowDarkness = 0.5;
          dirLight.shadowCameraVisible = true;


  //wholeHand.position()
  scene.add(ambLight);
  scene.add(sptLight);
  scene.add(dirLight);




  scene.add(topBox);
  // scene.add(wireOne);
  // scene.add(wireTwo);
  

  scene.add(bodyBox);
  scene.add(bodyTop);

  scene.add(wheelOne);
  scene.add(wheelTwo);
  scene.add(wholeHand);
  scene.add(wholeHand2);


  function animate() 

  {
    requestAnimationFrame( animate );
    render();   

  }


  function render() {
   glassEyeL.visible = false;
   glassEyeR.visible = false;

   glassEyeCamL.updateCubeMap(renderer, scene);
   glassEyeCamR.updateCubeMap(renderer, scene);
   glassEyeL.visible = true;
   glassEyeR.visible = true;
   renderer.render(scene, state.cameraObject); //re-render the scene using the TW camera
   

 }

 animate();

//  function showCP(cpList) {
//   for( var i=0; i < cpList.length; i++ ) {
//     scene.add(TW.createPoint(cpList[i]));
//   }
// };

  //showCP(controlPoints);          // optional, for debugging.
  TW.viewFromFront();        
  </script>
</body>
</html>
