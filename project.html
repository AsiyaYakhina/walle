

  <!-- 
Asiya Yakhina
Final project
-->
<html>
<head>
  <title>Wall-E scene</title>
  <style>      
  canvas {
    display: block;
    margin: 10px auto;
    width: 80%;
    height: 750px;
  }
  </style>
  <script src="http://cs.wellesley.edu/~cs307/threejs/libs/three.min.js"></script>
  <script src="http://cs.wellesley.edu/~cs307/threejs/libs/OrbitControls.js"></script>
  <script src="tw.js"></script>
  <script src="http://cs.wellesley.edu/~cs307/threejs/libs/dat.gui.min.js"></script>
  <script src="http://cs.wellesley.edu/~cs307/threejs/dirksen/libs/spin.js"></script>
  <script src="http://cs.wellesley.edu/~cs307/threejs/dirksen/libs/ThreeBSP.js"></script>
  <script src="marble.js"></script>
  <script src="eyeBase.js"></script>
  <script src="materials.js"></script>
  <script src="createHandwFaces.js"></script>
  <script src="createStem.js"></script>
  <script src="createEve.js"></script>
  <script src="createWallE.js"></script>

  

</head>
<body>

  <script id="prog">

  var renderer = new THREE.WebGLRenderer();
  //renderer.shadowMapEnabled = true;

  var animationState; //global to keep track of changes in penguin's position

  /* resetAnimationState
  Function that returns the animationState to its starting values so that the
  animation can be restarted.
  */
  function resetAnimationState() {
    animationState = {
      time: 0
    }
  }

  resetAnimationState();



  var scene = new THREE.Scene(); 
  TW.mainInit(renderer,scene);

  var state = TW.cameraSetup(renderer,scene, {minx:-10,maxx:10,miny:-30,maxy:20,minz:0,maxz:0}, 2, 600);
  state.cameraObject.near= 0;
  state.cameraObject.far = 500;



  var groundGeom = new THREE.PlaneGeometry(300,300);
  updateQuadTextureParams(groundGeom, 0, 10, 0, 10)
  var ground = new THREE.Mesh(groundGeom, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.set(0,-21.6,-70);
  scene.add(ground);

  var backgroundGeom = new THREE.CylinderGeometry(130,130,250,60,60,true);
  backgroundMat = new THREE.MeshBasicMaterial({color: 0xc9b195, side: THREE.BackSide});
  var background = new THREE.Mesh(backgroundGeom, backgroundMat);
  background.position.set(0,50,-60);
  scene.add(background);


  var glassEyeL;
  var glassEyeCamL; 
  var glassEyeR;
  var glassEyeCamR;
  var neckNhead;
  var hand;
  var head;
  var stem;

  var wallE = createWallE(); 

  wallE.position.set(-15,0,-10);
  wallE.rotation.y = Math.PI/8;
  scene.add(wallE);


  var eve = createEve();
  eve.position.set(14,-10,4);
  eve.rotation.y = Math.PI*2-Math.PI/5;
  scene.add(eve);

  scene.fog = new THREE.FogExp2( 0xc9b195, 0.007 );
  scene.fog.near = 30;


  ambLight= new THREE.AmbientLight( 0xA8A8A8, 0.01);


  sptLight = new THREE.SpotLight( 0x999999, 
               0.7,               //params.spotLightIntensity,
              300, //params.spotLightDistance,
              2,//params.spotLightAngle,
              20             //params.spotLightExp
              ); 
                   // positioning the bottom spotlight
                   sptLight.position.set( 0,50,-10);
                   

                   dirLight = new THREE.DirectionalLight(0xC2C2C2, 0.4);
          //setting up the light at a direction which will fall on the back, left walls and the floor
          dirLight.position.set(0.5, 1, 1);



  //wholeHand.position()
  scene.add(ambLight);
  scene.add(sptLight);
  scene.add(dirLight);


  params = {
    maxHandRotation: Math.PI/3,
    headMaxRotation: Math.PI/3,
    headTiltMax: Math.PI/10,
    headMotion_begin: 1,
    headMotion_end: 30,
    handMotion1_begin: 20,
    handMotion1_end: 50,
    headTilt_begin:40,
    headTilt_end:60,
    eveUp_begin: 55,
    eveUp_end: 65,
    eveDown_begin: 66,
    eveDown_end: 77,
    eveRotation: Math.PI*2,
    eveRotationInit: Math.PI*2-Math.PI/5,
    eveJumpHeight: 2,
    eveBack_begin:76,
    eveBack_end: 86,
    maxTS: 10
  }

  function resetState() {
    animationState = {
        rotation: 0, // fall from highest height
        eveRotationInit: Math.PI*2-Math.PI/5,
        time: 0
      };
    }


    function firstState() {
      resetState();
      hand.rotation.y=animationState.rotation;
      neckNhead.rotation.y= animationState.rotation;
      head.rotation.z=animationState.rotation;
      eve.rotation.y = animationState.eveRotationInit;

      TW.render();
    }

    function updateHead(ts){

     if (ts>params.headMotion_begin && ts < params.headMotion_end){
      neckNhead.rotation.y += params.headMaxRotation/ (params.headMotion_end-params.headMotion_begin);
    }
  }
  function updateHand(ts){

    if (ts>params.handMotion1_begin && ts < params.handMotion1_end){
      hand.rotation.y += params.maxHandRotation/ (params.handMotion1_end-params.handMotion1_begin);
      stem.rotation.y+= params.maxHandRotation/ (params.handMotion1_end-params.handMotion1_begin);
    }
  }

  function updateTilt(ts) {
    if (ts>params.headTilt_begin && ts < params.headTilt_end){
      head.rotation.z += params.headTiltMax/ (params.headTilt_end-params.headTilt_begin);
    }

  }

  function updateEve(ts) {
    if (ts>params.eveUp_begin && ts < params.eveUp_end){
     for (i = 0; i < 4; i++) { 
      eve.rotation.y += params.eveRotation/ (params.eveUp_end-params.eveUp_begin);
      eve.position.y +=params.eveJumpHeight/ (params.eveUp_end-params.eveUp_begin);
    }

  }
  if (ts>params.eveDown_begin && ts < params.eveDown_end){
   for (i = 0; i < 4; i++) { 
    eve.rotation.y += params.eveRotation/ (params.eveDown_end-params.eveDown_begin);

    eve.position.y -=params.eveJumpHeight/ (params.eveDown_end-params.eveDown_begin);
  }
}

if (ts>params.eveBack_begin && ts < params.eveBack_end) {
  eve.rotation.y += params.eveRotationInit/ (params.eveBack_end-params.eveBack_begin);
} 

}

function updateWalle(ts){
    //console.log("time is " + ts);
    updateHead(ts);
    updateHand(ts);
    updateTilt(ts);
    updateEve(ts);

    // if (ts> params.maxTS){
    //   stopAnimation();
    // }
  }

  function updateState(){
    animationState.time +=1;
    updateWalle(animationState.time);
  }


//value to stop the animation
var animationId = null;


function animateScene() {
  updateState();
  animationId = requestAnimationFrame( animateScene );
  renderer.render(scene, state.cameraObject);

}

function animate() {
  animationId = requestAnimationFrame( animate );
  render();
}
/*stopAnimation
Stops the animation if it's started.
*/
function stopAnimation() {

  if (animationId != null) {
    cancelAnimationFrame(animationId);
  }
}


function render() {
 glassEyeL.visible = false;
 glassEyeR.visible = false;

 glassEyeCamL.updateCubeMap(renderer, scene);
 glassEyeCamR.updateCubeMap(renderer, scene);
 glassEyeL.visible = true;
 glassEyeR.visible = true;
 renderer.render(scene, state.cameraObject); //re-render the scene using the TW camera
 }

 animate();

 TW.setKeyboardCallback("g",animateScene,"go:  start animation");
 TW.setKeyboardCallback("0",firstState,"reset animation");

 TW.viewFromFront();        
 </script>
</body>
</html>